// Code generated by gotdgen, DO NOT EDIT.

package td

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// KeyboardButton represents TL type `keyboardButton#a2fa4880`.
type KeyboardButton struct {
	// Text field of KeyboardButton.
	Text string
}

// KeyboardButtonTypeID is TL type id of KeyboardButton.
const KeyboardButtonTypeID = 0xa2fa4880

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButton) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButton.
var (
	_ bin.Encoder     = &KeyboardButton{}
	_ bin.Decoder     = &KeyboardButton{}
	_ bin.BareEncoder = &KeyboardButton{}
	_ bin.BareDecoder = &KeyboardButton{}

	_ KeyboardButtonClass = &KeyboardButton{}
)

func (k *KeyboardButton) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButton) String() string {
	if k == nil {
		return "KeyboardButton(nil)"
	}
	type Alias KeyboardButton
	return fmt.Sprintf("KeyboardButton%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButton) TypeID() uint32 {
	return KeyboardButtonTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButton) TypeName() string {
	return "keyboardButton"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButton) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButton",
		ID:   KeyboardButtonTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButton) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButton#a2fa4880 as nil")
	}
	b.PutID(KeyboardButtonTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButton) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButton#a2fa4880 as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButton) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButton#a2fa4880 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButton#a2fa4880: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButton) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButton#a2fa4880 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButton#a2fa4880: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButton) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonURL represents TL type `keyboardButtonUrl#258aff05`.
type KeyboardButtonURL struct {
	// Text field of KeyboardButtonURL.
	Text string
	// URL field of KeyboardButtonURL.
	URL string
}

// KeyboardButtonURLTypeID is TL type id of KeyboardButtonURL.
const KeyboardButtonURLTypeID = 0x258aff05

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonURL) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonURL.
var (
	_ bin.Encoder     = &KeyboardButtonURL{}
	_ bin.Decoder     = &KeyboardButtonURL{}
	_ bin.BareEncoder = &KeyboardButtonURL{}
	_ bin.BareDecoder = &KeyboardButtonURL{}

	_ KeyboardButtonClass = &KeyboardButtonURL{}
)

func (k *KeyboardButtonURL) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonURL) String() string {
	if k == nil {
		return "KeyboardButtonURL(nil)"
	}
	type Alias KeyboardButtonURL
	return fmt.Sprintf("KeyboardButtonURL%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonURL) TypeID() uint32 {
	return KeyboardButtonURLTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonURL) TypeName() string {
	return "keyboardButtonUrl"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonURL) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUrl",
		ID:   KeyboardButtonURLTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonURL) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrl#258aff05 as nil")
	}
	b.PutID(KeyboardButtonURLTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonURL) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrl#258aff05 as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.URL)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonURL) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrl#258aff05 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonURLTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonURL) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrl#258aff05 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrl#258aff05: field url: %w", err)
		}
		k.URL = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonURL) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetURL returns value of URL field.
func (k *KeyboardButtonURL) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// KeyboardButtonCallback represents TL type `keyboardButtonCallback#35bbdb6b`.
type KeyboardButtonCallback struct {
	// Flags field of KeyboardButtonCallback.
	Flags bin.Fields
	// RequiresPassword field of KeyboardButtonCallback.
	RequiresPassword bool
	// Text field of KeyboardButtonCallback.
	Text string
	// Data field of KeyboardButtonCallback.
	Data []byte
}

// KeyboardButtonCallbackTypeID is TL type id of KeyboardButtonCallback.
const KeyboardButtonCallbackTypeID = 0x35bbdb6b

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonCallback) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonCallback.
var (
	_ bin.Encoder     = &KeyboardButtonCallback{}
	_ bin.Decoder     = &KeyboardButtonCallback{}
	_ bin.BareEncoder = &KeyboardButtonCallback{}
	_ bin.BareDecoder = &KeyboardButtonCallback{}

	_ KeyboardButtonClass = &KeyboardButtonCallback{}
)

func (k *KeyboardButtonCallback) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.RequiresPassword == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.Data == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonCallback) String() string {
	if k == nil {
		return "KeyboardButtonCallback(nil)"
	}
	type Alias KeyboardButtonCallback
	return fmt.Sprintf("KeyboardButtonCallback%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonCallback) TypeID() uint32 {
	return KeyboardButtonCallbackTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonCallback) TypeName() string {
	return "keyboardButtonCallback"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonCallback) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonCallback",
		ID:   KeyboardButtonCallbackTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RequiresPassword",
			SchemaName: "requires_password",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Data",
			SchemaName: "data",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonCallback) SetFlags() {
	if !(k.RequiresPassword == false) {
		k.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonCallback) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCallback#35bbdb6b as nil")
	}
	b.PutID(KeyboardButtonCallbackTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonCallback) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonCallback#35bbdb6b as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonCallback#35bbdb6b: field flags: %w", err)
	}
	b.PutString(k.Text)
	b.PutBytes(k.Data)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonCallback) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCallback#35bbdb6b to nil")
	}
	if err := b.ConsumeID(KeyboardButtonCallbackTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonCallback) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonCallback#35bbdb6b to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field flags: %w", err)
		}
	}
	k.RequiresPassword = k.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonCallback#35bbdb6b: field data: %w", err)
		}
		k.Data = value
	}
	return nil
}

// SetRequiresPassword sets value of RequiresPassword conditional field.
func (k *KeyboardButtonCallback) SetRequiresPassword(value bool) {
	if value {
		k.Flags.Set(0)
		k.RequiresPassword = true
	} else {
		k.Flags.Unset(0)
		k.RequiresPassword = false
	}
}

// GetRequiresPassword returns value of RequiresPassword conditional field.
func (k *KeyboardButtonCallback) GetRequiresPassword() (value bool) {
	if k == nil {
		return
	}
	return k.Flags.Has(0)
}

// GetText returns value of Text field.
func (k *KeyboardButtonCallback) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetData returns value of Data field.
func (k *KeyboardButtonCallback) GetData() (value []byte) {
	if k == nil {
		return
	}
	return k.Data
}

// KeyboardButtonRequestPhone represents TL type `keyboardButtonRequestPhone#b16a6c29`.
type KeyboardButtonRequestPhone struct {
	// Text field of KeyboardButtonRequestPhone.
	Text string
}

// KeyboardButtonRequestPhoneTypeID is TL type id of KeyboardButtonRequestPhone.
const KeyboardButtonRequestPhoneTypeID = 0xb16a6c29

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPhone) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPhone.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPhone{}
	_ bin.Decoder     = &KeyboardButtonRequestPhone{}
	_ bin.BareEncoder = &KeyboardButtonRequestPhone{}
	_ bin.BareDecoder = &KeyboardButtonRequestPhone{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPhone{}
)

func (k *KeyboardButtonRequestPhone) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPhone) String() string {
	if k == nil {
		return "KeyboardButtonRequestPhone(nil)"
	}
	type Alias KeyboardButtonRequestPhone
	return fmt.Sprintf("KeyboardButtonRequestPhone%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPhone) TypeID() uint32 {
	return KeyboardButtonRequestPhoneTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPhone) TypeName() string {
	return "keyboardButtonRequestPhone"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPhone) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPhone",
		ID:   KeyboardButtonRequestPhoneTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPhone) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPhone#b16a6c29 as nil")
	}
	b.PutID(KeyboardButtonRequestPhoneTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPhone) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPhone#b16a6c29 as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPhone) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPhone#b16a6c29 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPhoneTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPhone#b16a6c29: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPhone) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPhone#b16a6c29 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPhone#b16a6c29: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPhone) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonRequestGeoLocation represents TL type `keyboardButtonRequestGeoLocation#fc796b3f`.
type KeyboardButtonRequestGeoLocation struct {
	// Text field of KeyboardButtonRequestGeoLocation.
	Text string
}

// KeyboardButtonRequestGeoLocationTypeID is TL type id of KeyboardButtonRequestGeoLocation.
const KeyboardButtonRequestGeoLocationTypeID = 0xfc796b3f

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestGeoLocation) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestGeoLocation.
var (
	_ bin.Encoder     = &KeyboardButtonRequestGeoLocation{}
	_ bin.Decoder     = &KeyboardButtonRequestGeoLocation{}
	_ bin.BareEncoder = &KeyboardButtonRequestGeoLocation{}
	_ bin.BareDecoder = &KeyboardButtonRequestGeoLocation{}

	_ KeyboardButtonClass = &KeyboardButtonRequestGeoLocation{}
)

func (k *KeyboardButtonRequestGeoLocation) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestGeoLocation) String() string {
	if k == nil {
		return "KeyboardButtonRequestGeoLocation(nil)"
	}
	type Alias KeyboardButtonRequestGeoLocation
	return fmt.Sprintf("KeyboardButtonRequestGeoLocation%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestGeoLocation) TypeID() uint32 {
	return KeyboardButtonRequestGeoLocationTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestGeoLocation) TypeName() string {
	return "keyboardButtonRequestGeoLocation"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestGeoLocation) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestGeoLocation",
		ID:   KeyboardButtonRequestGeoLocationTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestGeoLocation) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestGeoLocation#fc796b3f as nil")
	}
	b.PutID(KeyboardButtonRequestGeoLocationTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestGeoLocation) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestGeoLocation#fc796b3f as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestGeoLocation) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestGeoLocation#fc796b3f to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestGeoLocationTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestGeoLocation#fc796b3f: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestGeoLocation) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestGeoLocation#fc796b3f to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestGeoLocation#fc796b3f: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestGeoLocation) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonSwitchInline represents TL type `keyboardButtonSwitchInline#93b9fbb5`.
type KeyboardButtonSwitchInline struct {
	// Flags field of KeyboardButtonSwitchInline.
	Flags bin.Fields
	// SamePeer field of KeyboardButtonSwitchInline.
	SamePeer bool
	// Text field of KeyboardButtonSwitchInline.
	Text string
	// Query field of KeyboardButtonSwitchInline.
	Query string
	// PeerTypes field of KeyboardButtonSwitchInline.
	//
	// Use SetPeerTypes and GetPeerTypes helpers.
	PeerTypes []InlineQueryPeerTypeClass
}

// KeyboardButtonSwitchInlineTypeID is TL type id of KeyboardButtonSwitchInline.
const KeyboardButtonSwitchInlineTypeID = 0x93b9fbb5

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonSwitchInline) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonSwitchInline.
var (
	_ bin.Encoder     = &KeyboardButtonSwitchInline{}
	_ bin.Decoder     = &KeyboardButtonSwitchInline{}
	_ bin.BareEncoder = &KeyboardButtonSwitchInline{}
	_ bin.BareDecoder = &KeyboardButtonSwitchInline{}

	_ KeyboardButtonClass = &KeyboardButtonSwitchInline{}
)

func (k *KeyboardButtonSwitchInline) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.SamePeer == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.Query == "") {
		return false
	}
	if !(k.PeerTypes == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonSwitchInline) String() string {
	if k == nil {
		return "KeyboardButtonSwitchInline(nil)"
	}
	type Alias KeyboardButtonSwitchInline
	return fmt.Sprintf("KeyboardButtonSwitchInline%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonSwitchInline) TypeID() uint32 {
	return KeyboardButtonSwitchInlineTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonSwitchInline) TypeName() string {
	return "keyboardButtonSwitchInline"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonSwitchInline) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonSwitchInline",
		ID:   KeyboardButtonSwitchInlineTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "SamePeer",
			SchemaName: "same_peer",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "Query",
			SchemaName: "query",
		},
		{
			Name:       "PeerTypes",
			SchemaName: "peer_types",
			Null:       !k.Flags.Has(1),
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonSwitchInline) SetFlags() {
	if !(k.SamePeer == false) {
		k.Flags.Set(0)
	}
	if !(k.PeerTypes == nil) {
		k.Flags.Set(1)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonSwitchInline) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSwitchInline#93b9fbb5 as nil")
	}
	b.PutID(KeyboardButtonSwitchInlineTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonSwitchInline) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSwitchInline#93b9fbb5 as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonSwitchInline#93b9fbb5: field flags: %w", err)
	}
	b.PutString(k.Text)
	b.PutString(k.Query)
	if k.Flags.Has(1) {
		b.PutVectorHeader(len(k.PeerTypes))
		for idx, v := range k.PeerTypes {
			if v == nil {
				return fmt.Errorf("unable to encode keyboardButtonSwitchInline#93b9fbb5: field peer_types element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode keyboardButtonSwitchInline#93b9fbb5: field peer_types element with index %d: %w", idx, err)
			}
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonSwitchInline) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSwitchInline#93b9fbb5 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonSwitchInlineTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonSwitchInline) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSwitchInline#93b9fbb5 to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field flags: %w", err)
		}
	}
	k.SamePeer = k.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field query: %w", err)
		}
		k.Query = value
	}
	if k.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field peer_types: %w", err)
		}

		if headerLen > 0 {
			k.PeerTypes = make([]InlineQueryPeerTypeClass, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInlineQueryPeerType(b)
			if err != nil {
				return fmt.Errorf("unable to decode keyboardButtonSwitchInline#93b9fbb5: field peer_types: %w", err)
			}
			k.PeerTypes = append(k.PeerTypes, value)
		}
	}
	return nil
}

// SetSamePeer sets value of SamePeer conditional field.
func (k *KeyboardButtonSwitchInline) SetSamePeer(value bool) {
	if value {
		k.Flags.Set(0)
		k.SamePeer = true
	} else {
		k.Flags.Unset(0)
		k.SamePeer = false
	}
}

// GetSamePeer returns value of SamePeer conditional field.
func (k *KeyboardButtonSwitchInline) GetSamePeer() (value bool) {
	if k == nil {
		return
	}
	return k.Flags.Has(0)
}

// GetText returns value of Text field.
func (k *KeyboardButtonSwitchInline) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetQuery returns value of Query field.
func (k *KeyboardButtonSwitchInline) GetQuery() (value string) {
	if k == nil {
		return
	}
	return k.Query
}

// SetPeerTypes sets value of PeerTypes conditional field.
func (k *KeyboardButtonSwitchInline) SetPeerTypes(value []InlineQueryPeerTypeClass) {
	k.Flags.Set(1)
	k.PeerTypes = value
}

// GetPeerTypes returns value of PeerTypes conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonSwitchInline) GetPeerTypes() (value []InlineQueryPeerTypeClass, ok bool) {
	if k == nil {
		return
	}
	if !k.Flags.Has(1) {
		return value, false
	}
	return k.PeerTypes, true
}

// KeyboardButtonGame represents TL type `keyboardButtonGame#50f41ccf`.
type KeyboardButtonGame struct {
	// Text field of KeyboardButtonGame.
	Text string
}

// KeyboardButtonGameTypeID is TL type id of KeyboardButtonGame.
const KeyboardButtonGameTypeID = 0x50f41ccf

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonGame) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonGame.
var (
	_ bin.Encoder     = &KeyboardButtonGame{}
	_ bin.Decoder     = &KeyboardButtonGame{}
	_ bin.BareEncoder = &KeyboardButtonGame{}
	_ bin.BareDecoder = &KeyboardButtonGame{}

	_ KeyboardButtonClass = &KeyboardButtonGame{}
)

func (k *KeyboardButtonGame) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonGame) String() string {
	if k == nil {
		return "KeyboardButtonGame(nil)"
	}
	type Alias KeyboardButtonGame
	return fmt.Sprintf("KeyboardButtonGame%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonGame) TypeID() uint32 {
	return KeyboardButtonGameTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonGame) TypeName() string {
	return "keyboardButtonGame"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonGame) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonGame",
		ID:   KeyboardButtonGameTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonGame) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonGame#50f41ccf as nil")
	}
	b.PutID(KeyboardButtonGameTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonGame) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonGame#50f41ccf as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonGame) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonGame#50f41ccf to nil")
	}
	if err := b.ConsumeID(KeyboardButtonGameTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonGame#50f41ccf: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonGame) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonGame#50f41ccf to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonGame#50f41ccf: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonGame) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonBuy represents TL type `keyboardButtonBuy#afd93fbb`.
type KeyboardButtonBuy struct {
	// Text field of KeyboardButtonBuy.
	Text string
}

// KeyboardButtonBuyTypeID is TL type id of KeyboardButtonBuy.
const KeyboardButtonBuyTypeID = 0xafd93fbb

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonBuy) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonBuy.
var (
	_ bin.Encoder     = &KeyboardButtonBuy{}
	_ bin.Decoder     = &KeyboardButtonBuy{}
	_ bin.BareEncoder = &KeyboardButtonBuy{}
	_ bin.BareDecoder = &KeyboardButtonBuy{}

	_ KeyboardButtonClass = &KeyboardButtonBuy{}
)

func (k *KeyboardButtonBuy) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonBuy) String() string {
	if k == nil {
		return "KeyboardButtonBuy(nil)"
	}
	type Alias KeyboardButtonBuy
	return fmt.Sprintf("KeyboardButtonBuy%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonBuy) TypeID() uint32 {
	return KeyboardButtonBuyTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonBuy) TypeName() string {
	return "keyboardButtonBuy"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonBuy) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonBuy",
		ID:   KeyboardButtonBuyTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonBuy) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonBuy#afd93fbb as nil")
	}
	b.PutID(KeyboardButtonBuyTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonBuy) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonBuy#afd93fbb as nil")
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonBuy) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonBuy#afd93fbb to nil")
	}
	if err := b.ConsumeID(KeyboardButtonBuyTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonBuy#afd93fbb: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonBuy) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonBuy#afd93fbb to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonBuy#afd93fbb: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonBuy) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// KeyboardButtonURLAuth represents TL type `keyboardButtonUrlAuth#10b78d29`.
type KeyboardButtonURLAuth struct {
	// Flags field of KeyboardButtonURLAuth.
	Flags bin.Fields
	// Text field of KeyboardButtonURLAuth.
	Text string
	// FwdText field of KeyboardButtonURLAuth.
	//
	// Use SetFwdText and GetFwdText helpers.
	FwdText string
	// URL field of KeyboardButtonURLAuth.
	URL string
	// ButtonID field of KeyboardButtonURLAuth.
	ButtonID int
}

// KeyboardButtonURLAuthTypeID is TL type id of KeyboardButtonURLAuth.
const KeyboardButtonURLAuthTypeID = 0x10b78d29

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonURLAuth) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonURLAuth.
var (
	_ bin.Encoder     = &KeyboardButtonURLAuth{}
	_ bin.Decoder     = &KeyboardButtonURLAuth{}
	_ bin.BareEncoder = &KeyboardButtonURLAuth{}
	_ bin.BareDecoder = &KeyboardButtonURLAuth{}

	_ KeyboardButtonClass = &KeyboardButtonURLAuth{}
)

func (k *KeyboardButtonURLAuth) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.FwdText == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}
	if !(k.ButtonID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonURLAuth) String() string {
	if k == nil {
		return "KeyboardButtonURLAuth(nil)"
	}
	type Alias KeyboardButtonURLAuth
	return fmt.Sprintf("KeyboardButtonURLAuth%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonURLAuth) TypeID() uint32 {
	return KeyboardButtonURLAuthTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonURLAuth) TypeName() string {
	return "keyboardButtonUrlAuth"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonURLAuth) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUrlAuth",
		ID:   KeyboardButtonURLAuthTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "FwdText",
			SchemaName: "fwd_text",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonURLAuth) SetFlags() {
	if !(k.FwdText == "") {
		k.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonURLAuth) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrlAuth#10b78d29 as nil")
	}
	b.PutID(KeyboardButtonURLAuthTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonURLAuth) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUrlAuth#10b78d29 as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonUrlAuth#10b78d29: field flags: %w", err)
	}
	b.PutString(k.Text)
	if k.Flags.Has(0) {
		b.PutString(k.FwdText)
	}
	b.PutString(k.URL)
	b.PutInt(k.ButtonID)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonURLAuth) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrlAuth#10b78d29 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonURLAuthTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonURLAuth) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUrlAuth#10b78d29 to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field text: %w", err)
		}
		k.Text = value
	}
	if k.Flags.Has(0) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field fwd_text: %w", err)
		}
		k.FwdText = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field url: %w", err)
		}
		k.URL = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUrlAuth#10b78d29: field button_id: %w", err)
		}
		k.ButtonID = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonURLAuth) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// SetFwdText sets value of FwdText conditional field.
func (k *KeyboardButtonURLAuth) SetFwdText(value string) {
	k.Flags.Set(0)
	k.FwdText = value
}

// GetFwdText returns value of FwdText conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonURLAuth) GetFwdText() (value string, ok bool) {
	if k == nil {
		return
	}
	if !k.Flags.Has(0) {
		return value, false
	}
	return k.FwdText, true
}

// GetURL returns value of URL field.
func (k *KeyboardButtonURLAuth) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// GetButtonID returns value of ButtonID field.
func (k *KeyboardButtonURLAuth) GetButtonID() (value int) {
	if k == nil {
		return
	}
	return k.ButtonID
}

// InputKeyboardButtonURLAuth represents TL type `inputKeyboardButtonUrlAuth#d02e7fd4`.
type InputKeyboardButtonURLAuth struct {
	// Flags field of InputKeyboardButtonURLAuth.
	Flags bin.Fields
	// RequestWriteAccess field of InputKeyboardButtonURLAuth.
	RequestWriteAccess bool
	// Text field of InputKeyboardButtonURLAuth.
	Text string
	// FwdText field of InputKeyboardButtonURLAuth.
	//
	// Use SetFwdText and GetFwdText helpers.
	FwdText string
	// URL field of InputKeyboardButtonURLAuth.
	URL string
	// Bot field of InputKeyboardButtonURLAuth.
	Bot InputUserClass
}

// InputKeyboardButtonURLAuthTypeID is TL type id of InputKeyboardButtonURLAuth.
const InputKeyboardButtonURLAuthTypeID = 0xd02e7fd4

// construct implements constructor of KeyboardButtonClass.
func (i InputKeyboardButtonURLAuth) construct() KeyboardButtonClass { return &i }

// Ensuring interfaces in compile-time for InputKeyboardButtonURLAuth.
var (
	_ bin.Encoder     = &InputKeyboardButtonURLAuth{}
	_ bin.Decoder     = &InputKeyboardButtonURLAuth{}
	_ bin.BareEncoder = &InputKeyboardButtonURLAuth{}
	_ bin.BareDecoder = &InputKeyboardButtonURLAuth{}

	_ KeyboardButtonClass = &InputKeyboardButtonURLAuth{}
)

func (i *InputKeyboardButtonURLAuth) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Flags.Zero()) {
		return false
	}
	if !(i.RequestWriteAccess == false) {
		return false
	}
	if !(i.Text == "") {
		return false
	}
	if !(i.FwdText == "") {
		return false
	}
	if !(i.URL == "") {
		return false
	}
	if !(i.Bot == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputKeyboardButtonURLAuth) String() string {
	if i == nil {
		return "InputKeyboardButtonURLAuth(nil)"
	}
	type Alias InputKeyboardButtonURLAuth
	return fmt.Sprintf("InputKeyboardButtonURLAuth%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputKeyboardButtonURLAuth) TypeID() uint32 {
	return InputKeyboardButtonURLAuthTypeID
}

// TypeName returns name of type in TL schema.
func (*InputKeyboardButtonURLAuth) TypeName() string {
	return "inputKeyboardButtonUrlAuth"
}

// TypeInfo returns info about TL type.
func (i *InputKeyboardButtonURLAuth) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputKeyboardButtonUrlAuth",
		ID:   InputKeyboardButtonURLAuthTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "RequestWriteAccess",
			SchemaName: "request_write_access",
			Null:       !i.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "FwdText",
			SchemaName: "fwd_text",
			Null:       !i.Flags.Has(1),
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
		{
			Name:       "Bot",
			SchemaName: "bot",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (i *InputKeyboardButtonURLAuth) SetFlags() {
	if !(i.RequestWriteAccess == false) {
		i.Flags.Set(0)
	}
	if !(i.FwdText == "") {
		i.Flags.Set(1)
	}
}

// Encode implements bin.Encoder.
func (i *InputKeyboardButtonURLAuth) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUrlAuth#d02e7fd4 as nil")
	}
	b.PutID(InputKeyboardButtonURLAuthTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputKeyboardButtonURLAuth) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUrlAuth#d02e7fd4 as nil")
	}
	i.SetFlags()
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field flags: %w", err)
	}
	b.PutString(i.Text)
	if i.Flags.Has(1) {
		b.PutString(i.FwdText)
	}
	b.PutString(i.URL)
	if i.Bot == nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field bot is nil")
	}
	if err := i.Bot.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUrlAuth#d02e7fd4: field bot: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputKeyboardButtonURLAuth) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUrlAuth#d02e7fd4 to nil")
	}
	if err := b.ConsumeID(InputKeyboardButtonURLAuthTypeID); err != nil {
		return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputKeyboardButtonURLAuth) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUrlAuth#d02e7fd4 to nil")
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field flags: %w", err)
		}
	}
	i.RequestWriteAccess = i.Flags.Has(0)
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field text: %w", err)
		}
		i.Text = value
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field fwd_text: %w", err)
		}
		i.FwdText = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field url: %w", err)
		}
		i.URL = value
	}
	{
		value, err := DecodeInputUser(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUrlAuth#d02e7fd4: field bot: %w", err)
		}
		i.Bot = value
	}
	return nil
}

// SetRequestWriteAccess sets value of RequestWriteAccess conditional field.
func (i *InputKeyboardButtonURLAuth) SetRequestWriteAccess(value bool) {
	if value {
		i.Flags.Set(0)
		i.RequestWriteAccess = true
	} else {
		i.Flags.Unset(0)
		i.RequestWriteAccess = false
	}
}

// GetRequestWriteAccess returns value of RequestWriteAccess conditional field.
func (i *InputKeyboardButtonURLAuth) GetRequestWriteAccess() (value bool) {
	if i == nil {
		return
	}
	return i.Flags.Has(0)
}

// GetText returns value of Text field.
func (i *InputKeyboardButtonURLAuth) GetText() (value string) {
	if i == nil {
		return
	}
	return i.Text
}

// SetFwdText sets value of FwdText conditional field.
func (i *InputKeyboardButtonURLAuth) SetFwdText(value string) {
	i.Flags.Set(1)
	i.FwdText = value
}

// GetFwdText returns value of FwdText conditional field and
// boolean which is true if field was set.
func (i *InputKeyboardButtonURLAuth) GetFwdText() (value string, ok bool) {
	if i == nil {
		return
	}
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.FwdText, true
}

// GetURL returns value of URL field.
func (i *InputKeyboardButtonURLAuth) GetURL() (value string) {
	if i == nil {
		return
	}
	return i.URL
}

// GetBot returns value of Bot field.
func (i *InputKeyboardButtonURLAuth) GetBot() (value InputUserClass) {
	if i == nil {
		return
	}
	return i.Bot
}

// KeyboardButtonRequestPoll represents TL type `keyboardButtonRequestPoll#bbc7515d`.
type KeyboardButtonRequestPoll struct {
	// Flags field of KeyboardButtonRequestPoll.
	Flags bin.Fields
	// Quiz field of KeyboardButtonRequestPoll.
	//
	// Use SetQuiz and GetQuiz helpers.
	Quiz bool
	// Text field of KeyboardButtonRequestPoll.
	Text string
}

// KeyboardButtonRequestPollTypeID is TL type id of KeyboardButtonRequestPoll.
const KeyboardButtonRequestPollTypeID = 0xbbc7515d

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPoll) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPoll.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPoll{}
	_ bin.Decoder     = &KeyboardButtonRequestPoll{}
	_ bin.BareEncoder = &KeyboardButtonRequestPoll{}
	_ bin.BareDecoder = &KeyboardButtonRequestPoll{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPoll{}
)

func (k *KeyboardButtonRequestPoll) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Flags.Zero()) {
		return false
	}
	if !(k.Quiz == false) {
		return false
	}
	if !(k.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPoll) String() string {
	if k == nil {
		return "KeyboardButtonRequestPoll(nil)"
	}
	type Alias KeyboardButtonRequestPoll
	return fmt.Sprintf("KeyboardButtonRequestPoll%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPoll) TypeID() uint32 {
	return KeyboardButtonRequestPollTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPoll) TypeName() string {
	return "keyboardButtonRequestPoll"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPoll) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPoll",
		ID:   KeyboardButtonRequestPollTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Quiz",
			SchemaName: "quiz",
			Null:       !k.Flags.Has(0),
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// SetFlags sets flags for non-zero fields.
func (k *KeyboardButtonRequestPoll) SetFlags() {
	if !(k.Quiz == false) {
		k.Flags.Set(0)
	}
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPoll) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPoll#bbc7515d as nil")
	}
	b.PutID(KeyboardButtonRequestPollTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPoll) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPoll#bbc7515d as nil")
	}
	k.SetFlags()
	if err := k.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonRequestPoll#bbc7515d: field flags: %w", err)
	}
	if k.Flags.Has(0) {
		b.PutBool(k.Quiz)
	}
	b.PutString(k.Text)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPoll) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPoll#bbc7515d to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPollTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPoll) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPoll#bbc7515d to nil")
	}
	{
		if err := k.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field flags: %w", err)
		}
	}
	if k.Flags.Has(0) {
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field quiz: %w", err)
		}
		k.Quiz = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPoll#bbc7515d: field text: %w", err)
		}
		k.Text = value
	}
	return nil
}

// SetQuiz sets value of Quiz conditional field.
func (k *KeyboardButtonRequestPoll) SetQuiz(value bool) {
	k.Flags.Set(0)
	k.Quiz = value
}

// GetQuiz returns value of Quiz conditional field and
// boolean which is true if field was set.
func (k *KeyboardButtonRequestPoll) GetQuiz() (value bool, ok bool) {
	if k == nil {
		return
	}
	if !k.Flags.Has(0) {
		return value, false
	}
	return k.Quiz, true
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPoll) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// InputKeyboardButtonUserProfile represents TL type `inputKeyboardButtonUserProfile#e988037b`.
type InputKeyboardButtonUserProfile struct {
	// Text field of InputKeyboardButtonUserProfile.
	Text string
	// UserID field of InputKeyboardButtonUserProfile.
	UserID InputUserClass
}

// InputKeyboardButtonUserProfileTypeID is TL type id of InputKeyboardButtonUserProfile.
const InputKeyboardButtonUserProfileTypeID = 0xe988037b

// construct implements constructor of KeyboardButtonClass.
func (i InputKeyboardButtonUserProfile) construct() KeyboardButtonClass { return &i }

// Ensuring interfaces in compile-time for InputKeyboardButtonUserProfile.
var (
	_ bin.Encoder     = &InputKeyboardButtonUserProfile{}
	_ bin.Decoder     = &InputKeyboardButtonUserProfile{}
	_ bin.BareEncoder = &InputKeyboardButtonUserProfile{}
	_ bin.BareDecoder = &InputKeyboardButtonUserProfile{}

	_ KeyboardButtonClass = &InputKeyboardButtonUserProfile{}
)

func (i *InputKeyboardButtonUserProfile) Zero() bool {
	if i == nil {
		return true
	}
	if !(i.Text == "") {
		return false
	}
	if !(i.UserID == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (i *InputKeyboardButtonUserProfile) String() string {
	if i == nil {
		return "InputKeyboardButtonUserProfile(nil)"
	}
	type Alias InputKeyboardButtonUserProfile
	return fmt.Sprintf("InputKeyboardButtonUserProfile%+v", Alias(*i))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*InputKeyboardButtonUserProfile) TypeID() uint32 {
	return InputKeyboardButtonUserProfileTypeID
}

// TypeName returns name of type in TL schema.
func (*InputKeyboardButtonUserProfile) TypeName() string {
	return "inputKeyboardButtonUserProfile"
}

// TypeInfo returns info about TL type.
func (i *InputKeyboardButtonUserProfile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "inputKeyboardButtonUserProfile",
		ID:   InputKeyboardButtonUserProfileTypeID,
	}
	if i == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (i *InputKeyboardButtonUserProfile) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUserProfile#e988037b as nil")
	}
	b.PutID(InputKeyboardButtonUserProfileTypeID)
	return i.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (i *InputKeyboardButtonUserProfile) EncodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputKeyboardButtonUserProfile#e988037b as nil")
	}
	b.PutString(i.Text)
	if i.UserID == nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUserProfile#e988037b: field user_id is nil")
	}
	if err := i.UserID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputKeyboardButtonUserProfile#e988037b: field user_id: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputKeyboardButtonUserProfile) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUserProfile#e988037b to nil")
	}
	if err := b.ConsumeID(InputKeyboardButtonUserProfileTypeID); err != nil {
		return fmt.Errorf("unable to decode inputKeyboardButtonUserProfile#e988037b: %w", err)
	}
	return i.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (i *InputKeyboardButtonUserProfile) DecodeBare(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputKeyboardButtonUserProfile#e988037b to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUserProfile#e988037b: field text: %w", err)
		}
		i.Text = value
	}
	{
		value, err := DecodeInputUser(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputKeyboardButtonUserProfile#e988037b: field user_id: %w", err)
		}
		i.UserID = value
	}
	return nil
}

// GetText returns value of Text field.
func (i *InputKeyboardButtonUserProfile) GetText() (value string) {
	if i == nil {
		return
	}
	return i.Text
}

// GetUserID returns value of UserID field.
func (i *InputKeyboardButtonUserProfile) GetUserID() (value InputUserClass) {
	if i == nil {
		return
	}
	return i.UserID
}

// KeyboardButtonUserProfile represents TL type `keyboardButtonUserProfile#308660c1`.
type KeyboardButtonUserProfile struct {
	// Text field of KeyboardButtonUserProfile.
	Text string
	// UserID field of KeyboardButtonUserProfile.
	UserID int64
}

// KeyboardButtonUserProfileTypeID is TL type id of KeyboardButtonUserProfile.
const KeyboardButtonUserProfileTypeID = 0x308660c1

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonUserProfile) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonUserProfile.
var (
	_ bin.Encoder     = &KeyboardButtonUserProfile{}
	_ bin.Decoder     = &KeyboardButtonUserProfile{}
	_ bin.BareEncoder = &KeyboardButtonUserProfile{}
	_ bin.BareDecoder = &KeyboardButtonUserProfile{}

	_ KeyboardButtonClass = &KeyboardButtonUserProfile{}
)

func (k *KeyboardButtonUserProfile) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.UserID == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonUserProfile) String() string {
	if k == nil {
		return "KeyboardButtonUserProfile(nil)"
	}
	type Alias KeyboardButtonUserProfile
	return fmt.Sprintf("KeyboardButtonUserProfile%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonUserProfile) TypeID() uint32 {
	return KeyboardButtonUserProfileTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonUserProfile) TypeName() string {
	return "keyboardButtonUserProfile"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonUserProfile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonUserProfile",
		ID:   KeyboardButtonUserProfileTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "UserID",
			SchemaName: "user_id",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonUserProfile) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUserProfile#308660c1 as nil")
	}
	b.PutID(KeyboardButtonUserProfileTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonUserProfile) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonUserProfile#308660c1 as nil")
	}
	b.PutString(k.Text)
	b.PutLong(k.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonUserProfile) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUserProfile#308660c1 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonUserProfileTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonUserProfile#308660c1: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonUserProfile) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonUserProfile#308660c1 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUserProfile#308660c1: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonUserProfile#308660c1: field user_id: %w", err)
		}
		k.UserID = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonUserProfile) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetUserID returns value of UserID field.
func (k *KeyboardButtonUserProfile) GetUserID() (value int64) {
	if k == nil {
		return
	}
	return k.UserID
}

// KeyboardButtonWebView represents TL type `keyboardButtonWebView#13767230`.
type KeyboardButtonWebView struct {
	// Text field of KeyboardButtonWebView.
	Text string
	// URL field of KeyboardButtonWebView.
	URL string
}

// KeyboardButtonWebViewTypeID is TL type id of KeyboardButtonWebView.
const KeyboardButtonWebViewTypeID = 0x13767230

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonWebView) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonWebView.
var (
	_ bin.Encoder     = &KeyboardButtonWebView{}
	_ bin.Decoder     = &KeyboardButtonWebView{}
	_ bin.BareEncoder = &KeyboardButtonWebView{}
	_ bin.BareDecoder = &KeyboardButtonWebView{}

	_ KeyboardButtonClass = &KeyboardButtonWebView{}
)

func (k *KeyboardButtonWebView) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonWebView) String() string {
	if k == nil {
		return "KeyboardButtonWebView(nil)"
	}
	type Alias KeyboardButtonWebView
	return fmt.Sprintf("KeyboardButtonWebView%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonWebView) TypeID() uint32 {
	return KeyboardButtonWebViewTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonWebView) TypeName() string {
	return "keyboardButtonWebView"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonWebView) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonWebView",
		ID:   KeyboardButtonWebViewTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonWebView) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonWebView#13767230 as nil")
	}
	b.PutID(KeyboardButtonWebViewTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonWebView) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonWebView#13767230 as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.URL)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonWebView) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonWebView#13767230 to nil")
	}
	if err := b.ConsumeID(KeyboardButtonWebViewTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonWebView#13767230: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonWebView) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonWebView#13767230 to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonWebView#13767230: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonWebView#13767230: field url: %w", err)
		}
		k.URL = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonWebView) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetURL returns value of URL field.
func (k *KeyboardButtonWebView) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// KeyboardButtonSimpleWebView represents TL type `keyboardButtonSimpleWebView#a0c0505c`.
type KeyboardButtonSimpleWebView struct {
	// Text field of KeyboardButtonSimpleWebView.
	Text string
	// URL field of KeyboardButtonSimpleWebView.
	URL string
}

// KeyboardButtonSimpleWebViewTypeID is TL type id of KeyboardButtonSimpleWebView.
const KeyboardButtonSimpleWebViewTypeID = 0xa0c0505c

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonSimpleWebView) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonSimpleWebView.
var (
	_ bin.Encoder     = &KeyboardButtonSimpleWebView{}
	_ bin.Decoder     = &KeyboardButtonSimpleWebView{}
	_ bin.BareEncoder = &KeyboardButtonSimpleWebView{}
	_ bin.BareDecoder = &KeyboardButtonSimpleWebView{}

	_ KeyboardButtonClass = &KeyboardButtonSimpleWebView{}
)

func (k *KeyboardButtonSimpleWebView) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.URL == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonSimpleWebView) String() string {
	if k == nil {
		return "KeyboardButtonSimpleWebView(nil)"
	}
	type Alias KeyboardButtonSimpleWebView
	return fmt.Sprintf("KeyboardButtonSimpleWebView%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonSimpleWebView) TypeID() uint32 {
	return KeyboardButtonSimpleWebViewTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonSimpleWebView) TypeName() string {
	return "keyboardButtonSimpleWebView"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonSimpleWebView) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonSimpleWebView",
		ID:   KeyboardButtonSimpleWebViewTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "URL",
			SchemaName: "url",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonSimpleWebView) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSimpleWebView#a0c0505c as nil")
	}
	b.PutID(KeyboardButtonSimpleWebViewTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonSimpleWebView) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonSimpleWebView#a0c0505c as nil")
	}
	b.PutString(k.Text)
	b.PutString(k.URL)
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonSimpleWebView) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSimpleWebView#a0c0505c to nil")
	}
	if err := b.ConsumeID(KeyboardButtonSimpleWebViewTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonSimpleWebView#a0c0505c: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonSimpleWebView) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonSimpleWebView#a0c0505c to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSimpleWebView#a0c0505c: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonSimpleWebView#a0c0505c: field url: %w", err)
		}
		k.URL = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonSimpleWebView) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetURL returns value of URL field.
func (k *KeyboardButtonSimpleWebView) GetURL() (value string) {
	if k == nil {
		return
	}
	return k.URL
}

// KeyboardButtonRequestPeer represents TL type `keyboardButtonRequestPeer#d0b468c`.
type KeyboardButtonRequestPeer struct {
	// Text field of KeyboardButtonRequestPeer.
	Text string
	// ButtonID field of KeyboardButtonRequestPeer.
	ButtonID int
	// PeerType field of KeyboardButtonRequestPeer.
	PeerType RequestPeerTypeClass
}

// KeyboardButtonRequestPeerTypeID is TL type id of KeyboardButtonRequestPeer.
const KeyboardButtonRequestPeerTypeID = 0xd0b468c

// construct implements constructor of KeyboardButtonClass.
func (k KeyboardButtonRequestPeer) construct() KeyboardButtonClass { return &k }

// Ensuring interfaces in compile-time for KeyboardButtonRequestPeer.
var (
	_ bin.Encoder     = &KeyboardButtonRequestPeer{}
	_ bin.Decoder     = &KeyboardButtonRequestPeer{}
	_ bin.BareEncoder = &KeyboardButtonRequestPeer{}
	_ bin.BareDecoder = &KeyboardButtonRequestPeer{}

	_ KeyboardButtonClass = &KeyboardButtonRequestPeer{}
)

func (k *KeyboardButtonRequestPeer) Zero() bool {
	if k == nil {
		return true
	}
	if !(k.Text == "") {
		return false
	}
	if !(k.ButtonID == 0) {
		return false
	}
	if !(k.PeerType == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (k *KeyboardButtonRequestPeer) String() string {
	if k == nil {
		return "KeyboardButtonRequestPeer(nil)"
	}
	type Alias KeyboardButtonRequestPeer
	return fmt.Sprintf("KeyboardButtonRequestPeer%+v", Alias(*k))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*KeyboardButtonRequestPeer) TypeID() uint32 {
	return KeyboardButtonRequestPeerTypeID
}

// TypeName returns name of type in TL schema.
func (*KeyboardButtonRequestPeer) TypeName() string {
	return "keyboardButtonRequestPeer"
}

// TypeInfo returns info about TL type.
func (k *KeyboardButtonRequestPeer) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "keyboardButtonRequestPeer",
		ID:   KeyboardButtonRequestPeerTypeID,
	}
	if k == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Text",
			SchemaName: "text",
		},
		{
			Name:       "ButtonID",
			SchemaName: "button_id",
		},
		{
			Name:       "PeerType",
			SchemaName: "peer_type",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (k *KeyboardButtonRequestPeer) Encode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPeer#d0b468c as nil")
	}
	b.PutID(KeyboardButtonRequestPeerTypeID)
	return k.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (k *KeyboardButtonRequestPeer) EncodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't encode keyboardButtonRequestPeer#d0b468c as nil")
	}
	b.PutString(k.Text)
	b.PutInt(k.ButtonID)
	if k.PeerType == nil {
		return fmt.Errorf("unable to encode keyboardButtonRequestPeer#d0b468c: field peer_type is nil")
	}
	if err := k.PeerType.Encode(b); err != nil {
		return fmt.Errorf("unable to encode keyboardButtonRequestPeer#d0b468c: field peer_type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (k *KeyboardButtonRequestPeer) Decode(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPeer#d0b468c to nil")
	}
	if err := b.ConsumeID(KeyboardButtonRequestPeerTypeID); err != nil {
		return fmt.Errorf("unable to decode keyboardButtonRequestPeer#d0b468c: %w", err)
	}
	return k.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (k *KeyboardButtonRequestPeer) DecodeBare(b *bin.Buffer) error {
	if k == nil {
		return fmt.Errorf("can't decode keyboardButtonRequestPeer#d0b468c to nil")
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPeer#d0b468c: field text: %w", err)
		}
		k.Text = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPeer#d0b468c: field button_id: %w", err)
		}
		k.ButtonID = value
	}
	{
		value, err := DecodeRequestPeerType(b)
		if err != nil {
			return fmt.Errorf("unable to decode keyboardButtonRequestPeer#d0b468c: field peer_type: %w", err)
		}
		k.PeerType = value
	}
	return nil
}

// GetText returns value of Text field.
func (k *KeyboardButtonRequestPeer) GetText() (value string) {
	if k == nil {
		return
	}
	return k.Text
}

// GetButtonID returns value of ButtonID field.
func (k *KeyboardButtonRequestPeer) GetButtonID() (value int) {
	if k == nil {
		return
	}
	return k.ButtonID
}

// GetPeerType returns value of PeerType field.
func (k *KeyboardButtonRequestPeer) GetPeerType() (value RequestPeerTypeClass) {
	if k == nil {
		return
	}
	return k.PeerType
}

// KeyboardButtonClassName is schema name of KeyboardButtonClass.
const KeyboardButtonClassName = "KeyboardButton"

// KeyboardButtonClass represents KeyboardButton generic type.
//
// Example:
//
//	g, err := td.DecodeKeyboardButton(buf)
//	if err != nil {
//	    panic(err)
//	}
//	switch v := g.(type) {
//	case *td.KeyboardButton: // keyboardButton#a2fa4880
//	case *td.KeyboardButtonURL: // keyboardButtonUrl#258aff05
//	case *td.KeyboardButtonCallback: // keyboardButtonCallback#35bbdb6b
//	case *td.KeyboardButtonRequestPhone: // keyboardButtonRequestPhone#b16a6c29
//	case *td.KeyboardButtonRequestGeoLocation: // keyboardButtonRequestGeoLocation#fc796b3f
//	case *td.KeyboardButtonSwitchInline: // keyboardButtonSwitchInline#93b9fbb5
//	case *td.KeyboardButtonGame: // keyboardButtonGame#50f41ccf
//	case *td.KeyboardButtonBuy: // keyboardButtonBuy#afd93fbb
//	case *td.KeyboardButtonURLAuth: // keyboardButtonUrlAuth#10b78d29
//	case *td.InputKeyboardButtonURLAuth: // inputKeyboardButtonUrlAuth#d02e7fd4
//	case *td.KeyboardButtonRequestPoll: // keyboardButtonRequestPoll#bbc7515d
//	case *td.InputKeyboardButtonUserProfile: // inputKeyboardButtonUserProfile#e988037b
//	case *td.KeyboardButtonUserProfile: // keyboardButtonUserProfile#308660c1
//	case *td.KeyboardButtonWebView: // keyboardButtonWebView#13767230
//	case *td.KeyboardButtonSimpleWebView: // keyboardButtonSimpleWebView#a0c0505c
//	case *td.KeyboardButtonRequestPeer: // keyboardButtonRequestPeer#d0b468c
//	default: panic(v)
//	}
type KeyboardButtonClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	construct() KeyboardButtonClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Text field of KeyboardButton.
	GetText() (value string)
}

// DecodeKeyboardButton implements binary de-serialization for KeyboardButtonClass.
func DecodeKeyboardButton(buf *bin.Buffer) (KeyboardButtonClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case KeyboardButtonTypeID:
		// Decoding keyboardButton#a2fa4880.
		v := KeyboardButton{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonURLTypeID:
		// Decoding keyboardButtonUrl#258aff05.
		v := KeyboardButtonURL{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonCallbackTypeID:
		// Decoding keyboardButtonCallback#35bbdb6b.
		v := KeyboardButtonCallback{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPhoneTypeID:
		// Decoding keyboardButtonRequestPhone#b16a6c29.
		v := KeyboardButtonRequestPhone{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestGeoLocationTypeID:
		// Decoding keyboardButtonRequestGeoLocation#fc796b3f.
		v := KeyboardButtonRequestGeoLocation{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonSwitchInlineTypeID:
		// Decoding keyboardButtonSwitchInline#93b9fbb5.
		v := KeyboardButtonSwitchInline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonGameTypeID:
		// Decoding keyboardButtonGame#50f41ccf.
		v := KeyboardButtonGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonBuyTypeID:
		// Decoding keyboardButtonBuy#afd93fbb.
		v := KeyboardButtonBuy{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonURLAuthTypeID:
		// Decoding keyboardButtonUrlAuth#10b78d29.
		v := KeyboardButtonURLAuth{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case InputKeyboardButtonURLAuthTypeID:
		// Decoding inputKeyboardButtonUrlAuth#d02e7fd4.
		v := InputKeyboardButtonURLAuth{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPollTypeID:
		// Decoding keyboardButtonRequestPoll#bbc7515d.
		v := KeyboardButtonRequestPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case InputKeyboardButtonUserProfileTypeID:
		// Decoding inputKeyboardButtonUserProfile#e988037b.
		v := InputKeyboardButtonUserProfile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonUserProfileTypeID:
		// Decoding keyboardButtonUserProfile#308660c1.
		v := KeyboardButtonUserProfile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonWebViewTypeID:
		// Decoding keyboardButtonWebView#13767230.
		v := KeyboardButtonWebView{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonSimpleWebViewTypeID:
		// Decoding keyboardButtonSimpleWebView#a0c0505c.
		v := KeyboardButtonSimpleWebView{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	case KeyboardButtonRequestPeerTypeID:
		// Decoding keyboardButtonRequestPeer#d0b468c.
		v := KeyboardButtonRequestPeer{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode KeyboardButtonClass: %w", bin.NewUnexpectedID(id))
	}
}

// KeyboardButton boxes the KeyboardButtonClass providing a helper.
type KeyboardButtonBox struct {
	KeyboardButton KeyboardButtonClass
}

// Decode implements bin.Decoder for KeyboardButtonBox.
func (b *KeyboardButtonBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode KeyboardButtonBox to nil")
	}
	v, err := DecodeKeyboardButton(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.KeyboardButton = v
	return nil
}

// Encode implements bin.Encode for KeyboardButtonBox.
func (b *KeyboardButtonBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.KeyboardButton == nil {
		return fmt.Errorf("unable to encode KeyboardButtonClass as nil")
	}
	return b.KeyboardButton.Encode(buf)
}
